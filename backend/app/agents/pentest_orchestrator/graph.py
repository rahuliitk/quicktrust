"""LangGraph StateGraph wiring for pentest orchestrator."""
from langgraph.graph import StateGraph, END

from app.agents.pentest_orchestrator.state import PentestOrchestratorState
from app.agents.pentest_orchestrator.nodes import (
    load_org_context,
    generate_test_plan,
    simulate_findings,
    generate_report,
    save_results,
)


def build_graph():
    """Build the LangGraph state graph for pentest orchestrator."""
    graph = StateGraph(PentestOrchestratorState)

    graph.add_node("load_org_context", lambda state: state)
    graph.add_node("generate_test_plan", lambda state: state)
    graph.add_node("simulate_findings", lambda state: state)
    graph.add_node("generate_report", lambda state: state)
    graph.add_node("save_results", lambda state: state)

    graph.set_entry_point("load_org_context")
    graph.add_edge("load_org_context", "generate_test_plan")
    graph.add_edge("generate_test_plan", "simulate_findings")
    graph.add_edge("simulate_findings", "generate_report")
    graph.add_edge("generate_report", "save_results")
    graph.add_edge("save_results", END)

    return graph.compile()


async def run_pentest_orchestrator(
    db,
    org_id: str,
    agent_run_id: str,
) -> dict:
    """
    Run the full pentest orchestrator pipeline.
    Executes nodes sequentially with DB access rather than using LangGraph's
    built-in execution, since each node needs the async DB session.

    NOTE: This agent does NOT run actual penetration tests. It generates
    realistic test plans and simulated findings based on organizational context.
    """
    state: PentestOrchestratorState = {
        "org_id": org_id,
        "agent_run_id": agent_run_id,
    }

    node_funcs = [
        ("load_org_context", load_org_context),
        ("generate_test_plan", generate_test_plan),
        ("simulate_findings", simulate_findings),
        ("generate_report", generate_report),
        ("save_results", save_results),
    ]

    for node_name, node_func in node_funcs:
        result = await node_func(state, db)
        if result:
            state.update(result)

        if state.get("error") and node_name == "load_org_context":
            raise RuntimeError(state["error"])

    report = state.get("report_data", {})
    return {
        "report": report,
        "findings_count": report.get("executive_summary", {}).get("total_findings", 0),
        "overall_risk_rating": report.get("executive_summary", {}).get("overall_risk_rating", "unknown"),
        "saved": state.get("saved", False),
    }
